<html><head><title>Analog Output Record (ao)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="style.css">

</head>
<body class='pod'>
<!--
  generated by EPICS::PodHtml v,
  using Pod::Simple::PullParser v3.35,
  under Perl v5.028001 at Tue Jul 28 14:39:17 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to EPICS::PodHtml, and/or subclassing EPICS::PodHtml,
   then reconverting this document from the Pod source.
   When in doubt, email the author of EPICS::PodHtml for advice.
   See 'perldoc EPICS::PodHtml' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>
<div class="pod">


<h1><a class='u'
name="Analog-Output-Record-(ao)"
>Analog Output Record (ao)</a></h1>

<p>This record type is normally used to send an analog value to an output device,
converting it from engineering units into an integer value if necessary.
The record supports alarm and drive limits,
rate-of-change limiting,
output value integration,
linear and break-point conversion from engineering units,
and graphics and control limits.</p>

<h2><a class='u'
name="Record-specific-Menus"
>Record-specific Menus</a></h2>

<h3><a class='u'
name="Menu-aoOIF"
>Menu aoOIF</a></h3>

<p>The OIF field which uses this menu controls whether the record acts as an integrator (<code>Incremental</code>) or not (<code>Full</code>).</p>
<blockquote><table border="1"><tr>
<th>Index</th><th>Identifier</th><th>Choice String</th></tr>
<tr>
<td class='cell DBD_Menu index'>0</td>
<td class='cell DBD_Menu identifier'>aoOIF_Full</td>
<td class='cell DBD_Menu choice'>Full</td>
</tr>
<tr>
<td class='cell DBD_Menu index'>1</td>
<td class='cell DBD_Menu identifier'>aoOIF_Incremental</td>
<td class='cell DBD_Menu choice'>Incremental</td>
</tr>
</table></blockquote>


<h2><a class='u'
name="Parameter-Fields"
>Parameter Fields</a></h2>

<p>The record-specific fields are described below.</p>

<h3><a class='u'
name="Output-Value-Determination"
>Output Value Determination</a></h3>

<p>These fields control how the record determines the value to be output when it gets processed:</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">OMSL</td><td class="cell">Output Mode Select</td><td class="cell">MENU (<a href='menuOmsl.html'>menuOmsl</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">DOL</td><td class="cell">Desired Output Loc</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">OIF</td><td class="cell">Out Full/Incremental</td><td class="cell">MENU (<a href='#Menu-aoOIF'>aoOIF</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">PVAL</td><td class="cell">Previous value</td><td class="cell">DOUBLE</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">DRVH</td><td class="cell">Drive High Limit</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">DRVL</td><td class="cell">Drive Low Limit</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">VAL</td><td class="cell">Desired Output</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">OROC</td><td class="cell">Output Rate of Change</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">OVAL</td><td class="cell">Output Value</td><td class="cell">DOUBLE</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<p>The following steps are performed in order during record processing.</p>

<h4><a class='u'
name="Fetch-Value,-Integrate"
>Fetch Value,
Integrate</a></h4>

<p>The OMSL menu field is used to determine whether the DOL link and OIF menu fields should be used during processing or not:</p>

<ul>
<li>If OMSL is <code>supervisory</code> the DOL and OIF fields are not used.
The new output value is taken from the VAL field,
which may have been set from elsewhere.</li>

<li>If OMSL is <code>closed_loop</code> the DOL link field is read to obtain a value; if OIF is <code>Incremental</code> and the DOL link was read successfully,
the record&#39;s previous output value PVAL is added to it.</li>
</ul>

<h4><a class='u'
name="Drive-Limits"
>Drive Limits</a></h4>

<p>The output value is now clipped to the range DRVL to DRVH inclusive,
provided that DRVH &#62; DRVL.
The result is copied into both the VAL and PVAL fields.</p>

<h4><a class='u'
name="Limit-Rate-of-Change"
>Limit Rate of Change</a></h4>

<p>If the OROC field is not zero,
the VAL field is now adjusted so it is no more than OROC different to the previous output value given in OVAL.
OROC thus determines the maximum change in the output value that can occur each time the record gets processed.
The result is copied into the OVAL field,
which is used as the input to the following Units Conversion processing stage.</p>

<h3><a class='u'
name="Units-Conversion"
>Units Conversion</a></h3>

<p>...</p>

<p>For analog output records that do not use the Soft Channel device support routine,
the specified conversions (if any) are performed on the OVAL field and the resulting value in the RVAL field is sent to the address contained in the output link after it is adjusted by the values in the AOFF and ASLO fields.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">LINR</td><td class="cell">Linearization</td><td class="cell">MENU (<a href='menuConvert.html'>menuConvert</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">RVAL</td><td class="cell">Current Raw Value</td><td class="cell">LONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">ROFF</td><td class="cell">Raw Offset</td><td class="cell">ULONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">EGUF</td><td class="cell">Eng Units Full</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">EGUL</td><td class="cell">Eng Units Low</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">AOFF</td><td class="cell">Adjustment Offset</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">ASLO</td><td class="cell">Adjustment Slope</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">ESLO</td><td class="cell">EGU to Raw Slope</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">EOFF</td><td class="cell">EGU to Raw Offset</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

</table></blockquote>


<h4><a class='u'
name="Conversion-Related-Fields-and-the-Conversion-Process"
>Conversion Related Fields and the Conversion Process</a></h4>

<p>Except for analog outputs that use Soft Channel device support,
the LINR field determines if a conversion is performed and which conversion algorithm is used to convert OVAL to RVAL.</p>

<p>The LINR field can specify <code>LINEAR</code> or <code>SLOPE</code> for linear conversions,
<code>NO CONVERSION</code> for no conversions at all,
or the name of a breakpoint table such as <code>typeKdegC</code> for breakpoint conversions.</p>

<p>The EGUF and EGUL fields should be set for <code>LINEAR</code> conversions,
and the ESLO and EOFF fields for <code>SLOPE</code> conversion.
Note that none of these fields have any significance for records that use the Soft Channel device support module.</p>

<dl>
<dt><a name="EGUF,-EGUF"
>EGUF,
EGUF</a></dt>

<dd>
<p>The user must set these fields when configuring the database for records that use <code>LINEAR</code> conversions.
They are used to calculate the values for ESLO and EOFF.
See Conversion Specification for more information on how to calculate these fields.</p>

<dt><a name="ESLO,-EOFF"
>ESLO,
EOFF</a></dt>

<dd>
<p>Computed by device support from EGUF and EGUL when LINR specifies <code>LINEAR</code>.
These values must be supplied by the user when LINR specifies <code>SLOPE</code>.
Used only when LINR is <code>LINEAR</code> or <code>SLOPE</code>.</p>

<dt><a name="AOFF,-ASLO"
>AOFF,
ASLO</a></dt>

<dd>
<p>These fields are adjustment parameters for the raw output values.
They are applied to the raw output value after conversion from engineering units.</p>

<dt><a name="ROFF"
>ROFF</a></dt>

<dd>
<p>This field can be used to offset the raw value generated by the conversion process,
which is needed for some kinds of hardware.</p>
</dd>
</dl>

<p>Conversion proceeds as follows:</p>

<dl>
<dt><a 
>1.
If LINR==LINEAR or LINR==SLOPE,
then X = (VAL - EOFF) / ESLO,
else if LINR==NO_CONVERSION,
then X = VAL,
else X is obtained via breakpoint table.</a></dt>

<dd>
<dt><a name="2.-X-=-(X---AOFF)-/-ASLO"
>2.
X = (X - AOFF) / ASLO</a></dt>

<dd>
<dt><a name="3.-RVAL-=-round(X)---ROFF"
>3.
RVAL = round(X) - ROFF</a></dt>
</dl>

<p>To see how the Raw Soft Channel device support routine uses these fields,
see <a href="#Device-Support-For-Soft-Records" class="podlinkpod"
>&#34;Device Support For Soft Records&#34;</a> below for more information.</p>

<h3><a class='u'
name="Output-Specification"
>Output Specification</a></h3>

<p>The analog output record sends its desired output to the address in the OUT field.
For analog outputs that write their values to devices,
the OUT field must specify the address of the I/O card.
In addition,
the DTYP field must contain the name of the device support module.
Be aware that the address format differs according to the I/O bus used.
See Address Specification for information on the format of hardware addresses.</p>

<p>For soft records the output link can be a database link,
a channel access link,
or a constant value.
If the link is a constant,
no output is sent.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">DTYP</td><td class="cell">Device Type</td><td class="cell">DEVICE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">OUT</td><td class="cell">Output Specification</td><td class="cell">OUTLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Operator-Display-Parameters"
>Operator Display Parameters</a></h3>

<p>These parameters are used to present meaningful data to the operator.
They display the value and other parameters of the analog output either textually or graphically.</p>

<p>EGU is a string of up to 16 characters describing the units that the analog output measures.
It is retrieved by the get_units record support routine.</p>

<p>The HOPR and LOPR fields set the upper and lower display limits for the VAL,
OVAL,
PVAL,
HIHI,
HIGH,
LOW,
and LOLO fields.
Both the get_graphic_double and get_control_double record support routines retrieve these fields.
If these values are defined,
they must be in the range: DRVL &#60;= LOPR &#60;= HOPR &#60;= DRVH.</p>

<p>The PREC field determines the floating point precision with which to display VAL,
OVAL and PVAL.
It is used whenever the get_precision record support routine is called.</p>

<p>See <a href="dbCommonRecord.html#Operator-Display-Parameters" class="podlinkpod"
>Fields Common to All Record Types</a> for more on the record name (NAME) and description (DESC) fields.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">EGU</td><td class="cell">Engineering Units</td><td class="cell">STRING [16]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">HOPR</td><td class="cell">High Operating Range</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">LOPR</td><td class="cell">Low Operating Range</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">PREC</td><td class="cell">Display Precision</td><td class="cell">SHORT</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">NAME</td><td class="cell">Record Name</td><td class="cell">STRING [61]</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">DESC</td><td class="cell">Descriptor</td><td class="cell">STRING [41]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Alarm-Parameters"
>Alarm Parameters</a></h3>

<p>The possible alarm conditions for analog outputs are the SCAN,
READ,
INVALID and limit alarms.
The SCAN,
READ,
and INVALID alarms are called by the record or device support routines.</p>

<p>The limit alarms are configured by the user in the HIHI,
LOLO,
HIGH,
and LOW fields,
which must be floating-point values.
For each of these fields,
there is a corresponding severity field which can be either NO_ALARM,
MINOR,
or MAJOR.</p>

<p>See <a href="dbCommonOutput.html#Invalid-Output-Action-Fields" class="podlinkpod"
>Invalid Output Action Fields</a> for more information on the IVOA and IVOV fields.</p>

<p><a href="dbCommonRecord.html#Alarm-Fields" class="podlinkpod"
>Alarm Fields</a> lists other fields related to a alarms that are common to all record types.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">HIHI</td><td class="cell">Hihi Alarm Limit</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HIGH</td><td class="cell">High Alarm Limit</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LOW</td><td class="cell">Low Alarm Limit</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LOLO</td><td class="cell">Lolo Alarm Limit</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HHSV</td><td class="cell">Hihi Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HSV</td><td class="cell">High Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LSV</td><td class="cell">Low Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LLSV</td><td class="cell">Lolo Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HYST</td><td class="cell">Alarm Deadband</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">IVOA</td><td class="cell">INVALID output action</td><td class="cell">MENU (<a href='menuIvoa.html'>menuIvoa</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">IVOV</td><td class="cell">INVALID output value</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Monitor-Parameters"
>Monitor Parameters</a></h3>

<p>These parameters are used to specify deadbands for monitors on the VAL field.
The monitors are sent when the value field exceeds the last monitored field by the specified deadband.
If these fields have a value of zero,
everytime the value changes,
a monitor will be triggered; if they have a value of -1,
everytime the record is processed,
monitors are triggered.
ADEL is the deadband for archive monitors,
and MDEL the deadband for all other types of monitors.
See Monitor Specification for a complete explanation of monitors.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">ADEL</td><td class="cell">Archive Deadband</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">MDEL</td><td class="cell">Monitor Deadband</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Run-time-Parameters"
>Run-time Parameters</a></h3>

<p>These parameters are used by the run-time code for processing the analog output.
They are not configurable.
They represent the current state of the record.
The record support routines use some of them for more efficient processing.</p>

<p>The ORAW field is used to decide if monitors should be triggered for RVAL when monitors are triggered for VAL.
The RBV field is the actual read back value obtained from the hardware itself or from the associated device driver.
It is the responsibility of the device support routine to give this field a value.</p>

<p>ORBV is used to decide if monitors should be triggered for RBV at the same time monitors are triggered for changes in VAL.</p>

<p>The LALM,
MLST,
and ALST fields are used to implement the hysteresis factors for monitor callbacks.</p>

<p>The INIT field is used to initialize the LBRK field and for smoothing.</p>

<p>The PBRK field contains a pointer to the current breakpoint table (if any),
and LBRK contains a pointer to the last breakpoint table used.</p>

<p>The OMOD field indicates whether OVAL differs from VAL.
It will be different if VAL or OVAL have changed since the last time the record was processed,
or if VAL has been adjusted by OROC during the current processing.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">ORAW</td><td class="cell">Previous Raw Value</td><td class="cell">LONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">RBV</td><td class="cell">Readback Value</td><td class="cell">LONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">ORBV</td><td class="cell">Prev Readback Value</td><td class="cell">LONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">LALM</td><td class="cell">Last Value Alarmed</td><td class="cell">DOUBLE</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">ALST</td><td class="cell">Last Value Archived</td><td class="cell">DOUBLE</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">MLST</td><td class="cell">Last Val Monitored</td><td class="cell">DOUBLE</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">INIT</td><td class="cell">Initialized?</td><td class="cell">SHORT</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">PBRK</td><td class="cell">Ptrto brkTable</td><td class="cell">NOACCESS</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">No</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">LBRK</td><td class="cell">LastBreak Point</td><td class="cell">SHORT</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">PVAL</td><td class="cell">Previous value</td><td class="cell">DOUBLE</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">OMOD</td><td class="cell">Was OVAL modified?</td><td class="cell">UCHAR</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Simulation-Mode-Parameters"
>Simulation Mode Parameters</a></h3>

<p>The following fields are used to operate the record in simulation mode.</p>

<p>If SIMM (fetched through SIML) is YES,
the record is put in SIMS severity and the value is written through SIOL,
without conversion.
SSCN sets a different SCAN mechanism to use in simulation mode.
SDLY sets a delay (in sec) that is used for asynchronous simulation processing.</p>

<p>See <a href="dbCommonOutput.html#Output-Simulation-Fields" class="podlinkpod"
>Output Simulation Fields</a> for more information on simulation mode and its fields.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">SIML</td><td class="cell">Simulation Mode Link</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIMM</td><td class="cell">Simulation Mode</td><td class="cell">MENU (<a href='menuYesNo.html'>menuYesNo</a>)</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIOL</td><td class="cell">Simulation Output Link</td><td class="cell">OUTLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIMS</td><td class="cell">Simulation Mode Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SDLY</td><td class="cell">Sim. Mode Async Delay</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">-1.0</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SSCN</td><td class="cell">Sim. Mode Scan</td><td class="cell">MENU (<a href='menuScan.html'>menuScan</a>)</td><td class="cell">Yes</td><td class="cell">65535</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h2><a class='u'
name="Record-Support"
>Record Support</a></h2>

<h3><a class='u'
name="Record-Support-Routines"
>Record Support Routines</a></h3>

<p>The following are the record support routines that would be of interest to an application developer.
Other routines are the get_units,
get_precision,
get_graphic_double,
and get_control_double routines.</p>

<dl>
<dt><a name="init_record"
>init_record</a></dt>

<dd>
<p><code>long init_record(aoRecord *prec,
int pass);</code></p>

<p>This routine initializes SIMM if SIML is a constant or creates a channel access link if SIML is PV_LINK.
If SIOL is PV_LINK a channel access link is created.</p>

<p>This routine next checks to see that device support is available.
If DOL is a constant,
then VAL is initialized with its value and UDF is set to FALSE.</p>

<p>The routine next checks to see if the device support write routine is defined.
If either device support or the device support write routine does not exist,
an error message is issued and processing is terminated.</p>

<p>For compatibility with old device supports that don&#39;t know EOFF,
if both EOFF and ESLO have their default value,
EOFF is set to EGUL.</p>

<p>If device support includes <code>init_record()</code>,
it is called.</p>

<p>INIT is set TRUE.
This causes PBRK,
LBRK,
and smoothing to be re-initialized.
If &#34;backwards&#34; linear conversion is requested,
then VAL is computed from RVAL using the algorithm:</p>

<pre> VAL = ((RVAL+ROFF) * ASLO + AOFF) * ESLO + EOFF</pre>

<p>and UDF is set to FALSE.</p>

<p>For breakpoint conversion, a call is made to cvtEngToRawBpt and UDF is then set to FALSE. PVAL is set to VAL.</p>

<dt><a name="process"
>process</a></dt>

<dd>
<p><code>long process(aoRecord *prec);</code></p>

<p>See next section.</p>

<dt><a name="special"
>special</a></dt>

<dd>
<p><code>long special(DBADDR *paddr, int after);</code></p>

<p>The only special processing for analog output records is SPC_LINCONV which is invoked whenever either of the fields LINR, EGUF, EGUL or ROFF is changed If the device support routine special_linconv exists it is called.</p>

<p>INIT is set TRUE. This causes PBRK, LBRK, and smoothing to be re-initialized.</p>

<dt><a name="get_alarm_double"
>get_alarm_double</a></dt>

<dd>
<p><code>long get_alarm_double(DBADDR *, struct dbr_alDouble *);</code></p>

<p>Sets the following values:</p>

<pre> upper_alarm_limit = HIHI
 upper_warning_limit = HIGH
 lower_warning_limit = LOW
 lower_alarm_limit = LOLO</pre>
</dd>
</dl>

<h3><a class='u'
name="Record-Processing"
>Record Processing</a></h3>

<p>Routine process implements the following algorithm:</p>

<dl>
<dt><a 
>1. Check to see that the appropriate device support module exists. If it doesn&#39;t, an error message is issued and processing is terminated with the PACT field set to TRUE. This ensures that processes will no longer be called for this record. Thus error storms will not occur.</a></dt>

<dd>
<dt><a name="2.-Check-PACT:-If-PACT-is-FALSE-call-fetch_values-and-convert-which-perform-the-following-steps:"
>2. Check PACT: If PACT is FALSE call fetch_values and convert which perform the following steps:</a></dt>

<dd>
<ul>
<li>fetch_values:
<ul>
<li>if DOL is DB_LINK and OMSL is CLOSED_LOOP then get value from DOL</li>

<li>if OIF is INCREMENTAL then set value = value + VAL else value = VAL</li>
</ul>
</li>

<li>convert:
<ul>
<li>If Drive limits are defined force value to be within limits</li>

<li>Set VAL equal to value</li>

<li>Set UDF to FALSE.</li>

<li>If OVAL is undefined set it equal to value</li>

<li>If OROC is defined and not 0 make |value-OVAL| &#60;=OROC</li>

<li>Set OVAL equal to value</li>

<li>Compute RVAL from OVAL. using linear or break point table conversion. For linear conversions the algorithm is RVAL = (OVAL-EOFF)/ESLO.</li>

<li>For break point table conversion a call is made to cvtEngToRawBpt.</li>

<li>After that, for all conversion types AOFF, ASLO, and ROFF are calculated in, using the formula RVAL = (RVAL -AOFF) / ASLO - ROFF.</li>
</ul>
</li>
</ul>

<dt><a 
>3. Check alarms: This routine checks to see if the new VAL causes the alarm status and severity to change. If so, NSEV, NSTA and y are set. It also honors the alarm hysteresis factor (HYST). Thus the value must change by at least HYST before the alarm status and severity is reduced.</a></dt>

<dd>
<dt><a 
>4. Check severity and write the new value. See Invalid Alarm Output Action for details on how invalid alarms affect output records.</a></dt>

<dd>
<dt><a 
>5. If PACT has been changed to TRUE, the device support write output routine has started but has not completed writing the new value. In this case, the processing routine merely returns, leaving PACT TRUE.</a></dt>

<dd>
<dt><a name="6.-Check-to-see-if-monitors-should-be-invoked:"
>6. Check to see if monitors should be invoked:</a></dt>

<dd>
<ul>
<li>Alarm monitors are invoked if the alarm status or severity has changed.</li>

<li>Archive and value change monitors are invoked if ADEL and MDEL conditions are met.</li>

<li>Monitors for RVAL and for RBV are checked whenever other monitors are invoked.</li>

<li>NSEV and NSTA are reset to 0.</li>
</ul>

<dt><a name="7.-Scan-forward-link-if-necessary,-set-PACT-and-INIT-FALSE,-and-return."
>7. Scan forward link if necessary, set PACT and INIT FALSE, and return.</a></dt>
</dl>

<h2><a class='u'
name="Device-Support"
>Device Support</a></h2>

<h3><a class='u'
name="Fields-Of-Interest-To-Device-Support"
>Fields Of Interest To Device Support</a></h3>

<p>Each analog output record must have an associated set of device support routines. The primary responsibility of the device support routines is to output a new value whenever write_ao is called. The device support routines are primarily interested in the following fields:</p>

<ul>
<li>PACT &#8212; Process Active, used to indicate asynchronous completion</li>

<li>DPVT &#8212; Device Private, reserved for device support to use</li>

<li>OUT &#8212; Output Link, provides addressing information</li>

<li>EGUF &#8212; Engineering Units Full</li>

<li>EGUL &#8212; Engineering Units Low</li>

<li>ESLO &#8212; Engineering Unit Slope</li>

<li>EOFF &#8212; Engineering Unit Offset</li>

<li>OVAL &#8212; Output Value, in Engineering units</li>

<li>RVAL &#8212; Raw Output Value, after conversion</li>
</ul>

<h3><a class='u'
name="Device-Support-routines"
>Device Support routines</a></h3>

<p>Device support consists of the following routines:</p>

<dl>
<dt><a name="report"
>report</a></dt>

<dd>
<p><code>long report(int level);</code></p>

<p>This optional routine is called by the IOC command <code>dbior</code> and is passed the report level that was requested by the user. It should print a report on the state of the device support to stdout. The <code>level</code> parameter may be used to output increasingly more detailed information at higher levels, or to select different types of information with different levels. Level zero should print no more than a small summary.</p>

<dt><a name="init"
>init</a></dt>

<dd>
<p><code>long init(int after);</code></p>

<p>This optional routine is called twice at IOC initialization time. The first call happens before any of the <code>init_record()</code> calls are made, with the integer parameter <code>after</code> set to 0. The second call happens after all of the <code>init_record()</code> calls have been made, with <code>after</code> set to 1.</p>

<dt><a name="init_record"
>init_record</a></dt>

<dd>
<p><code>long init_record(aoRecord *prec);</code></p>

<p>This optional routine is called by the record initialization code for each ao record instance that has its DTYP field set to use this device support. It is normally used to check that the OUT address has the expected type and points to a valid device; to allocate any record-specific buffer space and other memory; and to connect any communication channels needed for the <code>write_ao()</code> routine to work properly.</p>

<p>If the record type&#39;s unit conversion features are used, the <code>init_record()</code> routine should calculate appropriate values for the ESLO and EOFF fields from the EGUL and EGUF field values. This calculation only has to be performed if the record&#39;s LINR field is set to <code>LINEAR</code>, but it is not necessary to check that condition first. This same calculation takes place in the <code>special_linconv()</code> routine, so the implementation can usually just call that routine to perform the task.</p>

<p>If the the last output value can be read back from the hardware, this routine should also fetch that value and put it into the record&#39;s RVAL or VAL field. The return value should be zero if the RVAL field has been set, or 2 if either the VAL field has been set or if the last output value cannot be retrieved.</p>

<dt><a name="get_ioint_info"
>get_ioint_info</a></dt>

<dd>
<p><code>long get_ioint_info(int cmd, aoRecord *prec, IOSCANPVT *piosl);</code></p>

<p>This optional routine is called whenever the record&#39;s SCAN field is being changed to or from the value <code>I/O Intr</code> to find out which I/O Interrupt Scan list the record should be added to or deleted from. If this routine is not provided, it will not be possible to set the SCAN field to the value <code>I/O Intr</code> at all.</p>

<p>The <code>cmd</code> parameter is zero when the record is being added to the scan list, and one when it is being removed from the list. The routine must determine which interrupt source the record should be connected to, which it indicates by the scan list that it points the location at <code>*piosl</code> to before returning. It can prevent the SCAN field from being changed at all by returning a non-zero value to its caller.</p>

<p>In most cases the device support will create the I/O Interrupt Scan lists that it returns for itself, by calling <code>void scanIoInit(IOSCANPVT *piosl)</code> once for each separate interrupt source. That API allocates memory and inializes the list, then passes back a pointer to the new list in the location at <code>*piosl</code>. When the device support receives notification that the interrupt has occurred, it announces that to the IOC by calling <code>void scanIoRequest(IOSCANPVT iosl)</code> which will arrange for the appropriate records to be processed in a suitable thread. The <code>scanIoRequest()</code> routine is safe to call from an interrupt service routine on embedded architectures (vxWorks and RTEMS).</p>

<dt><a name="write_ao"
>write_ao</a></dt>

<dd>
<p><code>long write_ao(aoRecord *prec);</code></p>

<p>This essential routine is called whenever the record has a new output value to send to the device. It is responsible for performing the write operation, using either the engineering units value found in the record&#39;s OVAL field, or the raw value from the record&#39;s RVAL field if the record type&#39;s unit conversion facilities are used. A return value of zero indicates success, any other value indicates that an error occurred.</p>

<p>This routine must not block (busy-wait) if the device takes more than a few microseconds to accept the new value. In that case the routine must use asynchronous completion to tell the record when the write operation eventually completes. It signals that this is an asynchronous operation by setting the record&#39;s PACT field to TRUE before it returns, having arranged for the record&#39;s <code>process()</code> routine to be called later once the write operation is over. When that happens the <code>write_ao()</code> routine will be called again with PACT still set to TRUE; it should then set it to FALSE to indicate the write has completed, and return.</p>

<dt><a name="special_linconv"
>special_linconv</a></dt>

<dd>
<p><code>long special_linconv(aoRecord *prec, int after);</code></p>

<p>This optional routine should be provided if the record type&#39;s unit conversion features are used by the device support&#39;s <code>write_ao()</code> routine utilizing the RVAL field rather than OVAL or VAL. It is called by the record code whenever any of the the fields LINR, EGUL or EGUF are modified and LINR has the value <code>LINEAR</code>. The routine must calculate and set the fields EOFF and ESLO appropriately based on the new values of EGUL and EGUF.</p>

<p>These calculations can be expressed in terms of the minimum and maximum raw values that the <code>write_ao()</code> routine can accept in the RVAL field. When VAL is EGUF the RVAL field will be set to <i>RVAL_max</i>, and when VAL is EGUL the RVAL field will become <i>RVAL_min</i>. The fomulae to use are:</p>

<blockquote>
<p>EOFF = (<i>RVAL_max</i> * EGUL &#8722; <i>RVAL_min</i> * EGUF) / (<i>RVAL_max</i> &#8722; <i>RVAL_min</i>)</p>

<p>ESLO = (EGUF &#8722; EGUL) / (<i>RVAL_max</i> &#8722; <i>RVAL_min</i>)</p>
</blockquote>

<p>Note that the record support sets EOFF to EGUL before calling this routine, which is a very common case (<i>RVAL_min</i> is zero).</p>
</dd>
</dl>

<h2><a class='u'
name="Device-Support-For-Soft-Records"
>Device Support For Soft Records</a></h2>

<p>Two soft device support modules Soft Channel and Raw Soft Channel are provided for output records not related to actual hardware devices. The OUT link type must be either a CONSTANT, DB_LINK, or CA_LINK.</p>

<h3><a class='u'
name="Soft-Channel"
>Soft Channel</a></h3>

<p>This module writes the current value of OVAL.</p>

<p>If the OUT link type is PV_LINK, then dbCaAddInlink is called by <code>init_record()</code>. <code>init_record()</code> always returns a value of 2, which means that no conversion will ever be attempted.</p>

<p>write_ao calls recGblPutLinkValue to write the current value of VAL. See Soft Output for details.</p>

<h3><a class='u'
name="Raw-Soft-Channel"
>Raw Soft Channel</a></h3>

<p>This module is like the previous except that it writes the current value of RVAL.</p>
</div>


<!-- end doc -->

</body></html>
