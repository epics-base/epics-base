#
# Author: Jim Kowalkowski
# Date: 2/96
#

Some Notes:

******
The following function described in gddAppTable.h and defined in gddAppDefs.cc:

	gddApplicationTypeTable* gddGenerateApplicationTypeTable(void);

is designed to be called in an application to create the type table
with a default set of attributes already registered.  The current mechanism
for generating the default registered attributes is the C++ code in
gddAppDefs.cc.  See this file for a list of registered attributes.

Creating am application type table using new will perform the same function.

******
The gddCleanUp object will automatically clean up the free list storage
when it is destructed.  There should only be one of these in an application.
It is not required.

******
To build for vxWorks, define an environment variable "VX_BUILD=vw" and type
make.  It will build for the HOST_ARCH architecture and then vxWorks.

You must have gcc/g++ 2.5.8 or later available to cross compile to 68k object
code and vxWorks.  You can get the gcc 2.5.8 package from the HiDEOS home
page along with instructions on building it.

The vxldscript.MRI file instructs the gnu loader on how to propare
object files to load under vxWorks.

You must use the ldpp program under vxWorks shell to load g++ generated
object modules.  The ldpp program is available in the EPICS base package.
Contact me if you want a copy of it.

It is really not difficult to get g++ object files to load under vxWorks
or to get the g++ compiled installed and running.  The makefile is set up
to handle builds for vxWorks.

******
aitTypes.h: Definitions of the architecture independant types.
aitTypes.c: definitions of several lookup tables
aitConvert.h: conversion table description,byte ordering routines
aitConvert.c: conversion information not generated
aitGen.c: creates the general conversion functions
aitConvertGenerated.c: file of generated conversion functions

dbMapper.cc: mappings from DBR types to ait types and GDDs
dbMapper.h: mappings from DBR types to ait types and GDDs

gddApps.h:
	This file contains "#define" statements for quick indexing into
	managed containers.  Generated by program genApps.cc.

*******
Still needed:

1) AppTable method to map application type to offset (index) into a 
   managed container.
* mostly complete

2) Function to map DBRxxxx types to Application types and back.
* still working on mapping method

3) Methods for managing network byte order conversions in gdd class.

4) Method to extract data (and bounds information) from a gdd into a
   user's buffer.

6) #defines to remove extra checks and make the programs run faster.

************ 6/13/96 *************

ref_cnt should be an unsigned short instead of char

menus need to be fixed - use aitFixedString or aitString

get/operator=() should be smarter, do conversion if types do not match

************ 6/20/96 **************

fix the flatten functions so they work properly with aitString and fixed
string

fix the aitString class, add the install string method and change others

*********** 6/21/96 ************

fixe the aitString::compact function, and all other stuff that works with
string info so that if the string that the aitString is holding is NULL,
then the system will act correctly.  The flatten functions have trouble
with this when the described string is NULL.

*********** 6/24/96 *************

still need to fix the transfer of aitString data into a pre-made gdd.
If only array of 5 aitString is placed into a pre-made array of 16,
then the last 11 should be initialized to NULLs or something, same for
fixed string - especially the fixed string

************** 6/26/96 ************

aitString:copy() still has troubles.  Need to correct the
aitConvertStringFloat64() and others.  How are they supposed to work?
Should they be calling aitString::installString() instead of copy()? Yes,
that is the answer.  In the convert functions, the temp variable
used to hold a value (character value) is always a stack variable and
needs to be copied.  Maybe the temp char variable should be copied over
the existing string if it will fit. No.

************** 8/28/96 ****************

network/host byte ordering issue:

Change isNetworkByteOrder() in class gdd to:
	isLocalDataFormat()   - true if data format is local host format
	isNetworkDataFormat() - true if data format is network format

	Both the above can be true at the same time if local host data format
	is the same as network data format

Add method to class gdd:
	markLocalDataFormat()
	markNotLocalDataFormat()

Modify putRef() functions of gdd class:
	add third argument to specify the byte order that data is in.
	default mode to local data format.  this turns out to be ugly
	because the second argument (gddDestructor*) defaults to NULL.
	But this is probably OK, since this will not be used often.

Modify getRef() functions of gdd class:
	add another argument that specifies the data format the user desires.
	default to local data format, first access to an array that is not
	in the correct format will cause the entire array to be converted
	to the desired format.

putConvert() and getConvert() notes:
	getConvert will always return values in local data format
	putConvert will always take local data format values as arguments

put() and get() notes:
	get always returns data in local data format
	put always takes data in local data format

Modify dbMapper.cc:
	add dbMapperToDbrMode({to_network_byte_order,keep_in_local_order})
	change all function to honor this mode setting
	any gdd converted to a dbr type could be change to network byte order
	depending on this mode.

Jim


