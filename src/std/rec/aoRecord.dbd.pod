#*************************************************************************
# Copyright (c) 2013 UChicago Argonne LLC, as Operator of Argonne
#     National Laboratory.
# Copyright (c) 2002 The Regents of the University of California, as
#     Operator of Los Alamos National Laboratory.
# EPICS BASE is distributed subject to a Software License Agreement found
# in file LICENSE that is included with this distribution. 
#*************************************************************************

=title Analog Output Record (ao)

This record type is normally used to send an analog value to an output device,
converting it from engineering units into an integer value if necessary.
The record supports alarm and drive limits, rate-of-change limiting, output
value integration, linear and break-point conversion from engineering units, and
graphics and control limits.

=head2 Record-specific Menus

=head3 Menu aoOIF

The OIF field which uses this menu controls whether the record acts as an
integrator (C<Incremental>) or not (C<Full>).

=menu aoOIF

=head2 Parameter Fields

The record-specific fields are described below.

=recordtype ao

=cut

menu(aoOIF) {
    choice(aoOIF_Full,"Full")
    choice(aoOIF_Incremental,"Incremental")
}

recordtype(ao) {

=head3 Output Value Determination

These fields control how the record determines the value to be output when it
gets processed:

=fields OMSL, DOL, OIF, PVAL, DRVH, DRVL, VAL, OROC, OVAL

The following steps are performed in order during record processing.

=head4 Fetch Value, Integrate

The OMSL menu field is used to determine whether the DOL link and OIF menu
fields should be used during processing or not:

=over

=item *
If OMSL is C<supervisory> the DOL and OIF fields are not used.
The new output value is taken from the VAL field, which may have been set from
elsewhere.

=item *
If OMSL is C<closed_loop> the DOL link field is read to obtain a value; if OIF
is C<Incremental> and the DOL link was read successfully, the record's previous
output value PVAL is added to it.

=back

=head4 Drive Limits

The output value is now clipped to the range DRVL to DRVH inclusive, provided
that DRVH > DRVL.
The result is copied into both the VAL and PVAL fields.

=head4 Limit Rate of Change

If the OROC field is not zero, the VAL field is now adjusted so it is no more
than OROC different to the previous output value given in OVAL.
OROC thus determines the maximum change in the output value that can occur each
time the record gets processed.
The result is copied into the OVAL field, which is used as the input to the
following Units Conversion processing stage.

=head3 Units Conversion

...


For analog output records that do not use the Soft Channel device support
routine, the specified conversions (if any) are performed on the OVAL field and
the resulting value in the RVAL field is sent to the address contained in the
output link after it is adjusted by the values in the AOFF and ASLO fields.

=fields LINR, RVAL, ROFF, EGUF, EGUL, AOFF, ASLO, ESLO, EOFF

=head4 Conversion Related Fields and the Conversion Process

Except for analog outputs that use Soft Channel device support, the LINR field
determines if a conversion is performed and which conversion algorithm is used
to convert OVAL to RVAL.

The LINR field can specify C<LINEAR> or C<SLOPE> for linear conversions,
C<NO CONVERSION> for no conversions at all, or the name of a breakpoint table
such as C<typeKdegC> for breakpoint conversions.

Note that the ESLO, EOFF, EGUF, and EGUL fields are only used for linear
conversions.
Also note that none of these fields have any significance for records that use
the Soft Channel device support module.

=over

=item EGUF, EGUF

The user must calculate these fields when configuring the database for records
that use C<LINEAR> conversions.
They are used to calculate the values for ESLO and EOFF.
See Conversion Specification for more information on how to calculate these
fields.

=item AOFF, ASLO

These fields are adjustment parameters for the raw output values.
They are applied to the raw output value after conversion from engineering
units.

=item ESLO, EOFF

Computed by device support using EGUF and EGUL when LINR specifies C<LINEAR>.
These values must be supplied by the user when LINR specifies C<SLOPE>.
Used only when LINR is C<LINEAR> or C<SLOPE>.

=item ROFF

This field can be used to offset the raw value generated by the conversion
process, which is needed for some kinds of hardware.

=back

Conversion proceeds as follows:

=over

=item 1. If LINR==LINEAR or LINR==SLOPE, then X = (VAL - EOFF) / ESLO,
else if LINR==NO_CONVERSION, then X = VAL,
else X is obtained via breakpoint table.

=item 2. X = (X - AOFF) / ASLO

=item 3. RVAL = round(X) - ROFF

=back

To see how the Raw Soft Channel device support routine uses these
fields, see L</Device Support For Soft Records> below for more
information.

=head3 Output Specification

The analog output record sends its desired output to the address in the
OUT field. For analog outputs that write their values to devices, the
OUT field must specify the address of the I/O card. In addition, the
DTYP field must contain the name of the device support module. Be aware
that the address format differs according to the I/O bus used. See
Address Specification for information on the format of hardware
addresses. The user can see a list of the device support modules
currently supported at the user's local site by using the dbst utility
in R3.13.

For soft records the output link can be a database link, a channel
access link, or a constant value. If the link is a constant, no output
is sent. See Address Specification for information on the format of
database and channel access addresses.

=fields DTYP, OUT

=head3 Operator Display Parameters

These parameters are used to present meaningful data to the operator.
They display the value and other parameters of the analog output either
textually or graphically.

EGU is a string of up to 16 characters describing the units that the
analog output measures. It is retrieved by the get_units record support
routine.

The HOPR and LOPR fields set the upper and lower display limits for the
VAL, OVAL, PVAL, HIHI, HIGH, LOW, and LOLO fields. Both the
get_graphic_double and get_control_double record support routines
retrieve these fields. If these values are defined, they must be in the
range: DRVL E<lt>= LOPR E<lt>= HOPR E<lt>= DRVH.

The PREC field determines the floating point precision with which to
display VAL, OVAL and PVAL. It is used whenever the get_precision
record support routine is called.

See Fields Common to All Record Types for more on the record name
(NAME) and description (DESC) fields.

=fields EGU, HOPR, LOPR, PREC, NAME, DESC

=head3 Alarm Parameters

The possible alarm conditions for analog outputs are the SCAN, READ,
INVALID and limit alarms. The SCAN, READ, and INVALID alarms are called
by the record or device support routines.

The limit alarms are configured by the user in the HIHI, LOLO, HIGH,
and LOW fields, which must be floating-point values. For each of these
fields, there is a corresponding severity field which can be either
NO_ALARM, MINOR, or MAJOR.

See Alarm Specification for a complete explanation of alarms and these
fields. See Invalid Alarm Output Action for more information on the
IVOA and IVOV fields. Alarm Fields lists other fields related to a
alarms that are common to all record types.

=fields HIHI, HIGH, LOW, LOLO, HHSV, HSV, LSV, LLSV, HYST, IVOA, IVOV

=head3 Monitor Parameters

These parameters are used to specify deadbands for monitors on the VAL
field. The monitors are sent when the value field exceeds the last
monitored field by the specified deadband. If these fields have a value
of zero, everytime the value changes, a monitor will be triggered; if
they have a value of -1, everytime the record is processed, monitors
are triggered. ADEL is the deadband for archive monitors, and MDEL the
deadband for all other types of monitors. See Monitor Specification for
a complete explanation of monitors.

=fields ADEL, MDEL

=head3 Run-time and Simulation Mode Parameters

These parameters are used by the run-time code for processing the
analog output. They are not configurable. They represent the current
state of the record. The record support routines use some of them for
more efficient processing.

The ORAW field is used to decide if monitors should be triggered for
RVAL when monitors are triggered for VAL. The RBV field is the actual
read back value obtained from the hardware itself or from the
associated device driver. It is the responsibility of the device
support routine to give this field a value.

ORBV is used to decide if monitors should be triggered for RBV at the
same time monitors are triggered for changes in VAL.

The LALM, MLST, and ALST fields are used to implement the hysteresis
factors for monitor callbacks.

The INIT field is used to initialize the LBRK field and for smoothing.

The PBRK field contains a pointer to the current breakpoint table (if
any), and LBRK contains a pointer to the last breakpoint table used.

The OMOD field indicates whether OVAL differs from VAL. It will be
different if VAL or OVAL have changed since the last time the record
was processed, or if VAL has been adjusted by OROC during the current
processing.

=fields ORAW, RBV, ORBV, LALM, ALST, MLST, INIT, PBRK, LBRK, PVAL, OMOD

The following fields are used to operate the analog output in the
simulation mode. See Fields Common to Many Record Types for more
information on these fields.

=fields SIOL, SIML, SIMM, SIMS

=cut

    include "dbCommon.dbd" 
    field(VAL,DBF_DOUBLE) {
        prompt("Desired Output")
        promptgroup("50 - Output")
        asl(ASL0)
        pp(TRUE)
    }
    field(OVAL,DBF_DOUBLE) {
        prompt("Output Value")
    }
    field(OUT,DBF_OUTLINK) {
        prompt("Output Specification")
        promptgroup("50 - Output")
        interest(1)
    }
    field(OROC,DBF_DOUBLE) {
        prompt("Output Rate of Change")
        promptgroup("50 - Output")
        interest(1)
    }
    field(DOL,DBF_INLINK) {
        prompt("Desired Output Loc")
        promptgroup("40 - Input")
        interest(1)
    }
    field(OMSL,DBF_MENU) {
        prompt("Output Mode Select")
        promptgroup("50 - Output")
        interest(1)
        menu(menuOmsl)
    }
    field(OIF,DBF_MENU) {
        prompt("Out Full/Incremental")
        promptgroup("50 - Output")
        interest(1)
        menu(aoOIF)
    }
    field(PREC,DBF_SHORT) {
        prompt("Display Precision")
        promptgroup("80 - Display")
        interest(1)
        prop(YES)
    }
    field(LINR,DBF_MENU) {
        prompt("Linearization")
        promptgroup("60 - Convert")
        special(SPC_LINCONV)
        pp(TRUE)
        interest(1)
        menu(menuConvert)
    }
    field(EGUF,DBF_DOUBLE) {
        prompt("Eng Units Full")
        promptgroup("60 - Convert")
        special(SPC_LINCONV)
        pp(TRUE)
        interest(1)
    }
    field(EGUL,DBF_DOUBLE) {
        prompt("Eng Units Low")
        promptgroup("60 - Convert")
        special(SPC_LINCONV)
        pp(TRUE)
        interest(1)
    }
    field(EGU,DBF_STRING) {
        prompt("Engineering Units")
        promptgroup("80 - Display")
        interest(1)
        size(16)
        prop(YES)
    }
    field(ROFF,DBF_ULONG) {
        prompt("Raw Offset")
        pp(TRUE)
        interest(2)
    }
    field(EOFF,DBF_DOUBLE) {
        prompt("EGU to Raw Offset")
        promptgroup("60 - Convert")
        pp(TRUE)
        interest(2)
    }
    field(ESLO,DBF_DOUBLE) {
        prompt("EGU to Raw Slope")
        promptgroup("60 - Convert")
        pp(TRUE)
        interest(2)
        initial("1")
    }
    field(DRVH,DBF_DOUBLE) {
        prompt("Drive High Limit")
        promptgroup("30 - Action")
        pp(TRUE)
        interest(1)
        prop(YES)
    }
    field(DRVL,DBF_DOUBLE) {
        prompt("Drive Low Limit")
        promptgroup("30 - Action")
        pp(TRUE)
        interest(1)
        prop(YES)
    }
    field(HOPR,DBF_DOUBLE) {
        prompt("High Operating Range")
        promptgroup("80 - Display")
        interest(1)
        prop(YES)
    }
    field(LOPR,DBF_DOUBLE) {
        prompt("Low Operating Range")
        promptgroup("80 - Display")
        interest(1)
        prop(YES)
    }
    field(AOFF,DBF_DOUBLE) {
        prompt("Adjustment Offset")
        promptgroup("60 - Convert")
        pp(TRUE)
        interest(1)
    }
    field(ASLO,DBF_DOUBLE) {
        prompt("Adjustment Slope")
        promptgroup("60 - Convert")
        pp(TRUE)
        interest(1)
    }
    field(HIHI,DBF_DOUBLE) {
        prompt("Hihi Alarm Limit")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
    }
    field(LOLO,DBF_DOUBLE) {
        prompt("Lolo Alarm Limit")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
    }
    field(HIGH,DBF_DOUBLE) {
        prompt("High Alarm Limit")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
    }
    field(LOW,DBF_DOUBLE) {
        prompt("Low Alarm Limit")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
    }
    field(HHSV,DBF_MENU) {
        prompt("Hihi Severity")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
        menu(menuAlarmSevr)
    }
    field(LLSV,DBF_MENU) {
        prompt("Lolo Severity")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
        menu(menuAlarmSevr)
    }
    field(HSV,DBF_MENU) {
        prompt("High Severity")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
        menu(menuAlarmSevr)
    }
    field(LSV,DBF_MENU) {
        prompt("Low Severity")
        promptgroup("70 - Alarm")
        pp(TRUE)
        interest(1)
        prop(YES)
        menu(menuAlarmSevr)
    }
    field(HYST,DBF_DOUBLE) {
        prompt("Alarm Deadband")
        promptgroup("70 - Alarm")
        interest(1)
    }
    field(ADEL,DBF_DOUBLE) {
        prompt("Archive Deadband")
        promptgroup("80 - Display")
        interest(1)
    }
    field(MDEL,DBF_DOUBLE) {
        prompt("Monitor Deadband")
        promptgroup("80 - Display")
        interest(1)
    }
    field(RVAL,DBF_LONG) {
        prompt("Current Raw Value")
        pp(TRUE)
    }
    field(ORAW,DBF_LONG) {
        prompt("Previous Raw Value")
        special(SPC_NOMOD)
        interest(3)
    }
    field(RBV,DBF_LONG) {
        prompt("Readback Value")
        special(SPC_NOMOD)
    }
    field(ORBV,DBF_LONG) {
        prompt("Prev Readback Value")
        special(SPC_NOMOD)
        interest(3)
    }
    field(PVAL,DBF_DOUBLE) {
        prompt("Previous value")
        special(SPC_NOMOD)
        interest(3)
    }
    field(LALM,DBF_DOUBLE) {
        prompt("Last Value Alarmed")
        special(SPC_NOMOD)
        interest(3)
    }
    field(ALST,DBF_DOUBLE) {
        prompt("Last Value Archived")
        special(SPC_NOMOD)
        interest(3)
    }
    field(MLST,DBF_DOUBLE) {
        prompt("Last Val Monitored")
        special(SPC_NOMOD)
        interest(3)
    }
    field(PBRK,DBF_NOACCESS) {
        prompt("Ptrto brkTable")
        special(SPC_NOMOD)
        interest(4)
        extra("void *   pbrk")
    }
    field(INIT,DBF_SHORT) {
        prompt("Initialized?")
        special(SPC_NOMOD)
        interest(3)
    }
    field(LBRK,DBF_SHORT) {
        prompt("LastBreak Point")
        special(SPC_NOMOD)
        interest(3)
    }
    field(SIOL,DBF_OUTLINK) {
        prompt("Sim Output Specifctn")
        promptgroup("90 - Simulate")
        interest(1)
    }
    field(SIML,DBF_INLINK) {
        prompt("Sim Mode Location")
        promptgroup("90 - Simulate")
        interest(1)
    }
    field(SIMM,DBF_MENU) {
        prompt("Simulation Mode")
        interest(1)
        menu(menuYesNo)
    }
    field(SIMS,DBF_MENU) {
        prompt("Sim mode Alarm Svrty")
        promptgroup("90 - Simulate")
        interest(2)
        menu(menuAlarmSevr)
    }
    field(IVOA,DBF_MENU) {
        prompt("INVALID output action")
        promptgroup("50 - Output")
        interest(2)
        menu(menuIvoa)
    }
    field(IVOV,DBF_DOUBLE) {
        prompt("INVALID output value")
        promptgroup("50 - Output")
        interest(2)
    }
    field(OMOD,DBF_UCHAR) {
        prompt("Was OVAL modified?")
        special(SPC_NOMOD)
    }
}

=head2 Record Support

=head3 Record Support Routines

The following are the record support routines that would be of interest
to an application developer. Other routines are the get_units,
get_precision, get_graphic_double, and get_control_double routines.

=over

=item init_record

This routine initializes SIMM if SIML is a constant or creates a
channel access link if SIML is PV_LINK. If SIOL is PV_LINK a channel
access link is created.

This routine next checks to see that device support is available. If
DOL is a constant, then VAL is initialized with its value and UDF is
set to FALSE.

The routine next checks to see if the device support write routine is
defined. If either device support or the device support write routine
does not exist, an error message is issued and processing is
terminated.

For compatibility with old device supports that don't know EOFF, if
both EOFF and ESLO have their default value, EOFF is set to EGUL.

If device support includes init_record, it is called.

INIT is set TRUE. This causes PBRK, LBRK, and smoothing to be
re-initialized. If "backwards" linear conversion is requested, then VAL
is computed from RVAL using the algorithm:

 VAL = ((RVAL+ROFF) * ASLO + AOFF) * ESLO + EOFF

and UDF is set to FALSE.

For breakpoint conversion, a call is made to cvtEngToRawBpt and UDF is
then set to FALSE. PVAL is set to VAL.

=item process

See next section.

=item special

The only special processing for analog output records is SPC_LINCONV
which is invoked whenever either of the fields LINR, EGUF, EGUL or ROFF
is changed If the device support routine special_linconv exists it is
called.

INIT is set TRUE. This causes PBRK, LBRK, and smoothing to be
re-initialized.

=item get_value

Fills in the values of struct valueDes so that they refer to VAL.

=item get_alarm_double

Sets the following values:

 upper_alarm_limit = HIHI
 upper_warning_limit = HIGH
 lower_warning_limit = LOW
 lower_alarm_limit = LOLO

=back

=head3 Record Processing

Routine process implements the following algorithm:

=over

=item 1. Check to see that the appropriate device support module
exists. If it doesn't, an error message is issued and processing is
terminated with the PACT field set to TRUE. This ensures that processes
will no longer be called for this record. Thus error storms will not
occur.

=item 2. Check PACT: If PACT is FALSE call fetch_values and convert
which perform the following steps:

=over

=item * fetch_values:

=over

=item * if DOL is DB_LINK and OMSL is CLOSED_LOOP then get value from
DOL

=item * if OIF is INCREMENTAL then set value = value + VAL else value =
VAL

=back

=item * convert:

=over

=item * If Drive limits are defined force value to be within limits

=item * Set VAL equal to value

=item * Set UDF to FALSE.

=item * If OVAL is undefined set it equal to value

=item * If OROC is defined and not 0 make |value-OVAL| E<lt>=OROC

=item * Set OVAL equal to value

=item * Compute RVAL from OVAL. using linear or break point table
conversion. For linear conversions the algorithm is RVAL =
(OVAL-EOFF)/ESLO.

=item * For break point table conversion a call is made to
cvtEngToRawBpt.

=item * After that, for all conversion types AOFF, ASLO, and ROFF are
calculated in, using the formula RVAL = (RVAL -AOFF) / ASLO - ROFF.

=back

=back

=item 3. Check alarms: This routine checks to see if the new VAL causes
the alarm status and severity to change. If so, NSEV, NSTA and y are
set. It also honors the alarm hysteresis factor (HYST). Thus the value
must change by at least HYST before the alarm status and severity is
reduced.

=item 4. Check severity and write the new value. See Invalid Alarm
Output Action for details on how invalid alarms affect output records.

=item 5. If PACT has been changed to TRUE, the device support write
output routine has started but has not completed writing the new value.
In this case, the processing routine merely returns, leaving PACT TRUE.

=item 6. Check to see if monitors should be invoked:

=over

=item * Alarm monitors are invoked if the alarm status or severity has
changed.

=item * Archive and value change monitors are invoked if ADEL and MDEL
conditions are met.

=item * Monitors for RVAL and for RBV are checked whenever other
monitors are invoked.

=item * NSEV and NSTA are reset to 0.

=back

=item 7. Scan forward link if necessary, set PACT and INIT FALSE, and
return.

=back

=head2 Device Support

=head3 Fields Of Interest To Device Support

Each analog output record must have an associated set of device support
routines. The primary responsibility of the device support routines is
to output a new value whenever write_ao is called. The device support
routines are primarily interested in the following fields:

=over

=item *
PACT E<mdash> Process Active, used to indicate asynchronous completion

=item *
DPVT E<mdash> Device Private, reserved for device support to use

=item *
OUT E<mdash> Output Link, provides addressing information

=item *
EGUF E<mdash> Engineering Units Full

=item *
EGUL E<mdash> Engineering Units Low

=item *
ESLO E<mdash> Engineering Unit Slope

=item *
EOFF E<mdash> Engineering Unit Offset

=item *
OVAL E<mdash> Output Value, in Engineering units

=item *
RVAL E<mdash> Raw Output Value, after conversion

=back

=head3 Device Support routines

Device support consists of the following routines:

=over

=item C<long report(int level)>

This optional routine is called by the IOC command C<dbior> and is passed the
report level that was requested by the user.
It should print a report on the state of the device support to stdout.
The C<level> parameter may be used to output increasingly more detailed
information at higher levels, or to select different types of information with
different levels.
Level zero should print no more than a small summary.

=item C<long init(int after)>

This optional routine is called twice at IOC initialization time.
The first call happens before any of the C<init_record()> calls are made, with
the integer parameter C<after> set to 0.
The second call happens after all of the C<init_record()> calls have been made,
with C<after> set to 1.

=item C<long init_record(aoRecord *prec)>

This optional routine is called by the record initialization code for each ao
record instance that has its DTYP field set to use this device support.
It is normally used to check that the OUT address has the expected type and
points to a valid device; to allocate any record-specific buffer space and
other memory; and to connect any communication channels needed for the
C<write_ao()> routine to work properly.

If the record type's unit conversion features are used, the C<init_record()>
routine should calculate appropriate values for the ESLO and EOFF fields from
the EGUL and EGUF field values.
This calculation only has to be performed if the record's LINR field is set to
C<LINEAR>, but it is not necessary to check that condition first.
This same calculation takes place in the C<special_linconv()> routine, so the
implementation can usually just call that routine to perform the task.

If the the last output value can be read back from the hardware, this routine
should also fetch that value and put it into the record's RVAL or VAL field. The
return value should be zero if the RVAL field has been set, or 2 if either the
VAL field has been set or if the last output value cannot be retrieved.

=item C<long get_ioint_info(int cmd, aoRecord *prec, IOSCANPVT *piosl)>

This optional routine is called whenever the record's SCAN field is being
changed to or from the value C<I/O Intr> to find out which I/O Interrupt Scan
list the record should be added to or deleted from.
If this routine is not provided, it will not be possible to set the SCAN field
to the value C<I/O Intr> at all.

The C<cmd> parameter is zero when the record is being added to the scan list,
and one when it is being removed from the list.
The routine must determine which interrupt source the record should be connected
to, which it indicates by the scan list that it points the location at C<*piosl>
to before returning.
It can prevent the SCAN field from being changed at all by returning a non-zero
value to its caller.

In most cases the device support will create the I/O Interrupt Scan lists that
it returns for itself, by calling C<void scanIoInit(IOSCANPVT *piosl)> once for
each separate interrupt source.
That API allocates memory and inializes the list, then passes back a pointer to
the new list in the location at C<*piosl>.
When the device support receives notification that the interrupt has occurred,
it announces that to the IOC by calling C<void scanIoRequest(IOSCANPVT iosl)>
which will arrange for the appropriate records to be processed in a suitable
thread.
The C<scanIoRequest()> routine is safe to call from an interrupt service routine
on embedded architectures (vxWorks and RTEMS).

=item C<long write_ao(aoRecord *prec)>

This essential routine is called whenever the record has a new output value to
send to the device. It is responsible for performing the write operation, using
either the engineering units value found in the record's OVAL field, or the raw
value from the record's RVAL field if the record type's unit conversion
facilities are used. A return value of zero indicates success, any other value
indicates that an error occurred.

This routine must not block (busy-wait) if the device takes more than a few
microseconds to accept the new value. In that case the routine must use
asynchronous completion to tell the record when the write operation eventually
completes. It signals that this is an asynchronous operation by setting the
record's PACT field to TRUE before it returns, having arranged for the record's
C<process()> routine to be called later once the write operation is over. When
that happens the C<write_ao()> routine will be called again with PACT still set
to TRUE; it should then set it to FALSE to indicate the write has completed, and
return.

=item C<long special_linconv(aoRecord *prec, int after)>

This optional routine should be provided if the record type's unit conversion
features are used by the device support's C<write_ao()> routine utilizing the
RVAL field rather than OVAL or VAL.
It is called by the record code whenever any of the the fields LINR, EGUL or
EGUF are modified and LINR has the value C<LINEAR>.
The routine must calculate and set the fields EOFF and ESLO appropriately based
on the new values of EGUL and EGUF.

These calculations can be expressed in terms of the minimum and maximum raw
values that the C<write_ao()> routine can accept in the RVAL field.
When VAL is EGUF the RVAL field will be set to I<RVAL_max>, and when VAL is
EGUL the RVAL field will become I<RVAL_min>.
The fomulae to use are:

=over

EOFF = (I<RVAL_max> * EGUL E<minus> I<RVAL_min> * EGUF) /
(I<RVAL_max> E<minus> I<RVAL_min>)

ESLO = (EGUF E<minus> EGUL) / (I<RVAL_max> E<minus> I<RVAL_min>)

=back

Note that the record support sets EOFF to EGUL before calling this routine,
which is a very common case (I<RVAL_min> is zero).

=back

=head2 Device Support For Soft Records

Two soft device support modules Soft Channel and Raw Soft Channel are
provided for output records not related to actual hardware devices. The
OUT link type must be either a CONSTANT, DB_LINK, or CA_LINK.

=head3 Soft Channel

This module writes the current value of OVAL.

If the OUT link type is PV_LINK, then dbCaAddInlink is called by
init_record. init_record always returns a value of 2, which means that
no conversion will ever be attempted.

write_ao calls recGblPutLinkValue to write the current value of VAL.
See Soft Output for details.

=head3 Raw Soft Channel

This module is like the previous except that it writes the current
value of RVAL.

=cut
