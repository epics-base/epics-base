<html><head><title>64bit Integer Input Record (int64in)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="style.css">

</head>
<body class='pod'>
<!--
  generated by EPICS::PodHtml v,
  using Pod::Simple::PullParser v3.35,
  under Perl v5.028001 at Tue Jul 28 14:39:17 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to EPICS::PodHtml, and/or subclassing EPICS::PodHtml,
   then reconverting this document from the Pod source.
   When in doubt, email the author of EPICS::PodHtml for advice.
   See 'perldoc EPICS::PodHtml' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>
<div class="pod">


<h1><a class='u'
name="64bit-Integer-Input-Record-(int64in)"
>64bit Integer Input Record (int64in)</a></h1>

<p>This record type is normally used to obtain an integer value of up to 64 bits from a hardware input.
The record supports alarm limits,
alarm filtering,
graphics and control limits.</p>

<h2><a class='u'
name="Parameter-Fields"
>Parameter Fields</a></h2>

<p>The record-specific fields are described below.</p>

<h3><a class='u'
name="Input-Specification"
>Input Specification</a></h3>

<p>These fields control where the record will read data from when it is processed:</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">DTYP</td><td class="cell">Device Type</td><td class="cell">DEVICE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">INP</td><td class="cell">Input Specification</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<p>The DTYP field selects which device support layer should be responsible for providing input data to the record.
The int64in device support layers provided by EPICS Base are documented in the <a href="#Device-Support" class="podlinkpod"
>&#34;Device Support&#34;</a> section.
External support modules may provide additional device support for this record type.
If not set explicitly,
the DTYP value defaults to the first device support that is loaded for the record type,
which will usually be the <code>Soft Channel</code> support that comes with Base.</p>

<p>The INP link field contains a database or channel access link or provides hardware address information that the device support uses to determine where the input data should come from.</p>

<h3><a class='u'
name="Operator-Display-Parameters"
>Operator Display Parameters</a></h3>

<p>These parameters are used to present meaningful data to the operator.
They do not affect the functioning of the record.</p>

<ul>
<li>DESC is a string that is usually used to briefly describe the record.</li>

<li>EGU is a string of up to 16 characters naming the engineering units that the VAL field represents.</li>

<li>The HOPR and LOPR fields set the upper and lower display limits for the VAL,
HIHI,
HIGH,
LOW,
and LOLO fields.</li>
</ul>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">DESC</td><td class="cell">Descriptor</td><td class="cell">STRING [41]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">EGU</td><td class="cell">Units name</td><td class="cell">STRING [16]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">HOPR</td><td class="cell">High Operating Range</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">LOPR</td><td class="cell">Low Operating Range</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Alarm-Limits"
>Alarm Limits</a></h3>

<p>The user configures limit alarms by putting numerical values into the HIHI,
HIGH,
LOW and LOLO fields,
and by setting the associated alarm severity in the corresponding HHSV,
HSV,
LSV and LLSV menu fields.</p>

<p>The HYST field controls hysteresis to prevent alarm chattering from an input signal that is close to one of the limits and suffers from significant readout noise.</p>

<p>The AFTC field sets the time constant on a low-pass filter that delays the reporting of limit alarms until the signal has been within the alarm range for that number of seconds (the default AFTC value of zero retains the previous behavior).</p>

<p>The LALM field is used by the record at run-time to implement the alarm limit functionality.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">HIHI</td><td class="cell">Hihi Alarm Limit</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HIGH</td><td class="cell">High Alarm Limit</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LOW</td><td class="cell">Low Alarm Limit</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LOLO</td><td class="cell">Lolo Alarm Limit</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HHSV</td><td class="cell">Hihi Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HSV</td><td class="cell">High Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LSV</td><td class="cell">Low Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">LLSV</td><td class="cell">Lolo Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">HYST</td><td class="cell">Alarm Deadband</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">AFTC</td><td class="cell">Alarm Filter Time Constant</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">LALM</td><td class="cell">Last Value Alarmed</td><td class="cell">INT64</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Monitor-Parameters"
>Monitor Parameters</a></h3>

<p>These parameters are used to determine when to send monitors placed on the VAL field.
The monitors are sent when the current value exceeds the last transmitted value by the appropriate deadband.
If these fields are set to zero,
a monitor will be triggered every time the value changes; if set to -1,
a monitor will be sent every time the record is processed.</p>

<p>The ADEL field sets the deadband for archive monitors (<code>DBE_LOG</code> events),
while the MDEL field controls value monitors (<code>DBE_VALUE</code> events).</p>

<p>The remaining fields are used by the record at run-time to implement the record monitoring deadband functionality.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">ADEL</td><td class="cell">Archive Deadband</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">MDEL</td><td class="cell">Monitor Deadband</td><td class="cell">INT64</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">ALST</td><td class="cell">Last Value Archived</td><td class="cell">INT64</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">MLST</td><td class="cell">Last Val Monitored</td><td class="cell">INT64</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Simulation-Mode-Parameters"
>Simulation Mode Parameters</a></h3>

<p>The following fields are used to operate the record in simulation mode.</p>

<p>If SIMM (fetched through SIML) is YES,
the record is put in SIMS severity and the value is fetched through SIOL (buffered in SVAL).
SSCN sets a different SCAN mechanism to use in simulation mode.
SDLY sets a delay (in sec) that is used for asynchronous simulation processing.</p>

<p>See <a href="dbCommonInput.html#Input-Simulation-Fields" class="podlinkpod"
>Input Simulation Fields</a> for more information on simulation mode and its fields.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">SIML</td><td class="cell">Simulation Mode Link</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIMM</td><td class="cell">Simulation Mode</td><td class="cell">MENU (<a href='menuYesNo.html'>menuYesNo</a>)</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIOL</td><td class="cell">Simulation Input Link</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SVAL</td><td class="cell">Simulation Value</td><td class="cell">INT64</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIMS</td><td class="cell">Simulation Mode Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SDLY</td><td class="cell">Sim. Mode Async Delay</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">-1.0</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SSCN</td><td class="cell">Sim. Mode Scan</td><td class="cell">MENU (<a href='menuScan.html'>menuScan</a>)</td><td class="cell">Yes</td><td class="cell">65535</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h2><a class='u'
name="Record-Support"
>Record Support</a></h2>

<h3><a class='u'
name="Record-Support-Routines"
>Record Support Routines</a></h3>

<p>The following are the record support routines that would be of interest to an application developer.
Other routines are the <code>get_units</code>,
<code>get_graphic_double</code>,
<code>get_alarm_double</code> and <code>get_control_double</code> routines,
which are used to collect properties from the record for the complex DBR data structures.</p>

<h4><a class='u'
name="init_record"
>init_record</a></h4>

<p>This routine first initializes the simulation mode mechanism by setting SIMM if SIML is a constant,
and setting SVAL if SIOL is a constant.</p>

<p>It then checks if the device support and the device support&#39;s <code>read_int64in</code> routine are defined.
If either one does not exist,
an error message is issued and processing is terminated.</p>

<p>If device support includes <code>init_record</code>,
it is called.</p>

<p>Finally,
the deadband mechanisms for monitors and level alarms are initialized.</p>

<h4><a class='u'
name="process"
>process</a></h4>

<p>See next section.</p>

<h3><a class='u'
name="Record-Processing"
>Record Processing</a></h3>

<p>Routine <code>process</code> implements the following algorithm:</p>

<ol>
<li>Check to see that the appropriate device support module and its <code>read_int64in</code> routine are defined.
If either one does not exist,
an error message is issued and processing is terminated with the PACT field set to TRUE,
effectively blocking the record to avoid error storms.</li>

<li>Determine the value:
<p>If PACT is TRUE,
call the device support <code>read_int64in</code> routine and return.</p>

<p>If PACT is FALSE,
read the value,
honoring simulation mode:</p>

<ul>
<li>Get SIMM by reading the SIML link.</li>

<li>If SIMM is <code>NO</code>,
call the device support <code>read_int64in</code> routine and return.</li>

<li>If SIMM is <code>YES</code>,
then
<ul>
<li>Set alarm status to SIMM_ALARM and severity to SIMS,
if SIMS is greater than zero.</li>

<li>If the record simulation processing is synchronous (SDLY &#60; 0) or the record is in the second phase of an asynchronous processing,
call <code>dbGetLink()</code> to read the input value from SIOL into SVAL.
Set status to the return code from <code>dbGetLink()</code>.
If the call succeeded,
write the value to VAL and set UDF to 0.
<p>Otherwise (record is in first phase of an asynchronous processing),
set up a callback processing with the delay specified in SDLY.</p>
</li>
</ul>
</li>

<li>Raise an alarm for other values of SIMM.</li>
</ul>
</li>

<li>If PACT has been changed to TRUE,
the device support signals asynchronous processing: its <code>read_int64in</code> output routine has started,
but not completed reading the new value.
In this case,
the processing routine merely returns,
leaving PACT TRUE.</li>

<li>Set PACT to TRUE.
Get the processing time stamp.
Set UDF to 0 if reading the value was successful.</li>

<li>Check UDF and level alarms: This routine checks to see if the record is undefined (UDF is TRUE) or if the new VAL causes the alarm status and severity to change.
In the latter case,
NSEV,
NSTA and LALM are set.
It also honors the alarm hysteresis factor (HYST): the value must change by at least HYST between level alarm status and severity changes.
If AFTC is set,
alarm level filtering is applied.</li>

<li>Check to see if monitors should be invoked:
<ul>
<li>Alarm monitors are posted if the alarm status or severity have changed.</li>

<li>Archive and value change monitors are posted if ADEL and MDEL conditions (see <a href="#Monitor-Parameters" class="podlinkpod"
>&#34;Monitor Parameters&#34;</a>) are met.</li>
</ul>
</li>

<li>Scan (process) forward link if necessary,
set PACT to FALSE,
and return.</li>
</ol>

<h2><a class='u'
name="Device-Support"
>Device Support</a></h2>

<h3><a class='u'
name="Device-Support-Interface"
>Device Support Interface</a></h3>

<p>The record requires device support to provide an entry table (dset) which defines the following members:</p>

<pre> typedef struct {
     long number;
     long (*report)(int level);
     long (*init)(int after);
     long (*init_record)(int64inRecord *prec);
     long (*get_ioint_info)(int cmd, int64inRecord *prec, IOSCANPVT *piosl);
     long (*read_int64in)(int64inRecord *prec);
 } int64indset;</pre>

<p>The module must set <code>number</code> to at least 5, and provide a pointer to its <code>read_int64in()</code> routine; the other function pointers may be <code>NULL</code> if their associated functionality is not required for this support layer. Most device supports also provide an <code>init_record()</code> routine to configure the record instance and connect it to the hardware or driver support layer.</p>

<p>The individual routines are described below.</p>

<h3><a class='u'
name="Device-Support-Routines"
>Device Support Routines</a></h3>

<h4><a class='u'
name="long-report(int-level)"
>long report(int level)</a></h4>

<p>This optional routine is called by the IOC command <code>dbior</code> and is passed the report level that was requested by the user. It should print a report on the state of the device support to stdout. The <code>level</code> parameter may be used to output increasingly more detailed information at higher levels, or to select different types of information with different levels. Level zero should print no more than a small summary.</p>

<h4><a class='u'
name="long-init(int-after)"
>long init(int after)</a></h4>

<p>This optional routine is called twice at IOC initialization time. The first call happens before any of the <code>init_record()</code> calls are made, with the integer parameter <code>after</code> set to 0. The second call happens after all of the <code>init_record()</code> calls have been made, with <code>after</code> set to 1.</p>

<h4><a class='u'
name="long-init_record(int64inRecord-*prec)"
>long init_record(int64inRecord *prec)</a></h4>

<p>This optional routine is called by the record initialization code for each int64in record instance that has its DTYP field set to use this device support. It is normally used to check that the INP address is the expected type and that it points to a valid device; to allocate any record-specific buffer space and other memory; and to connect any communication channels needed for the <code>read_int64in()</code> routine to work properly.</p>

<h4><a class='u'
name="long-get_ioint_info(int-cmd,-int64inRecord-*prec,-IOSCANPVT-*piosl)"
>long get_ioint_info(int cmd, int64inRecord *prec, IOSCANPVT *piosl)</a></h4>

<p>This optional routine is called whenever the record&#39;s SCAN field is being changed to or from the value <code>I/O Intr</code> to find out which I/O Interrupt Scan list the record should be added to or deleted from. If this routine is not provided, it will not be possible to set the SCAN field to the value <code>I/O Intr</code> at all.</p>

<p>The <code>cmd</code> parameter is zero when the record is being added to the scan list, and one when it is being removed from the list. The routine must determine which interrupt source the record should be connected to, which it indicates by the scan list that it points the location at <code>*piosl</code> to before returning. It can prevent the SCAN field from being changed at all by returning a non-zero value to its caller.</p>

<p>In most cases the device support will create the I/O Interrupt Scan lists that it returns for itself, by calling <code>void scanIoInit(IOSCANPVT *piosl)</code> once for each separate interrupt source. That routine allocates memory and inializes the list, then passes back a pointer to the new list in the location at <code>*piosl</code>.</p>

<p>When the device support receives notification that the interrupt has occurred, it announces that to the IOC by calling <code>void scanIoRequest(IOSCANPVT iosl)</code> which will arrange for the appropriate records to be processed in a suitable thread. The <code>scanIoRequest()</code> routine is safe to call from an interrupt service routine on embedded architectures (vxWorks and RTEMS).</p>

<h4><a class='u'
name="long-read_int64in(int64inRecord-*prec)"
>long read_int64in(int64inRecord *prec)</a></h4>

<p>This essential routine is called when the record wants a new value from the addressed device. It is responsible for performing (or at least initiating) a read operation, and (eventually) returning its value to the record.</p>

<p>If the device may take more than a few microseconds to return the new value, this routine must never block (busy-wait), but use the asynchronous processing mechanism. In that case it signals the asynchronous operation by setting the record&#39;s PACT field to TRUE before it returns, having arranged for the record&#39;s <code>process()</code> routine to be called later once the read operation is finished. When that happens, the <code>read_int64in()</code> routine will be called again with PACT still set to TRUE; it should then set it to FALSE to indicate the read has completed, and return.</p>

<p>A return value of zero indicates success, any other value indicates that an error occurred.</p>

<h3><a class='u'
name="Extended-Device-Support"
>Extended Device Support</a></h3>

<p>...</p>

<h2><a class='u'
name="Device-Support-For-Soft-Records"
>Device Support For Soft Records</a></h2>

<p>Two soft device support modules, Soft Channel and Soft Callback Channel, are provided for input records not related to actual hardware devices. The INP link type must be either a CONSTANT, DB_LINK, or CA_LINK.</p>

<h3><a class='u'
name="Soft-Channel"
>Soft Channel</a></h3>

<p>This module reads the value using the record&#39;s INP link.</p>

<p><code>read_int64in</code> calls <code>dbGetLink</code> to read the value.</p>

<h3><a class='u'
name="Soft-Callback-Channel"
>Soft Callback Channel</a></h3>

<p>This module is like the previous except that it reads the value using asynchronous processing that will not complete until an asynchronous processing of the INP target record has completed.</p>
</div>


<!-- end doc -->

</body></html>
