<html><head><title>Waveform Record (waveform)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="style.css">

</head>
<body class='pod'>
<!--
  generated by EPICS::PodHtml v,
  using Pod::Simple::PullParser v3.35,
  under Perl v5.028001 at Tue Jul 28 14:39:16 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to EPICS::PodHtml, and/or subclassing EPICS::PodHtml,
   then reconverting this document from the Pod source.
   When in doubt, email the author of EPICS::PodHtml for advice.
   See 'perldoc EPICS::PodHtml' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>
<div class="pod">


<h1><a class='u'
name="Waveform-Record-(waveform)"
>Waveform Record (waveform)</a></h1>

<p>The waveform record type is used to interface waveform digitizers.
The record stores its data in arrays.
The array can contain any of the supported data types.</p>

<h2><a class='u'
name="Parameter-Fields"
>Parameter Fields</a></h2>

<p>The record-specific fields are described below,
grouped by functionality.</p>

<h3><a class='u'
name="Scan-Parameters"
>Scan Parameters</a></h3>

<p>The waveform record has the standard fields for specifying under what circumstances the record will be processed.
These fields are listed in <a href="dbCommonRecord.html#Scan-Fields" class="podlinkpod"
>Scan Fields</a>.</p>

<h3><a class='u'
name="Read-Parameters"
>Read Parameters</a></h3>

<p>These fields are configurable by the user to specify how and from where the record reads its data.
How the INP field is configured determines where the waveform gets its input.
It can be a hardware address,
a channel access or database link,
or a constant.
Only in records that use soft device support can the INP field be a channel access link,
a database link,
or a constant.
Otherwise,
the INP field must be a hardware address.</p>

<h4><a class='u'
name="Fields-related-to-waveform-reading"
>Fields related to waveform reading</a></h4>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">DTYP</td><td class="cell">Device Type</td><td class="cell">DEVICE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">INP</td><td class="cell">Input Specification</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">NELM</td><td class="cell">Number of Elements</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">FTVL</td><td class="cell">Field Type of Value</td><td class="cell">MENU (<a href='menuFtype.html'>menuFtype</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">RARM</td><td class="cell">Rearm the waveform</td><td class="cell">SHORT</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

</table></blockquote>


<p>The DTYP field must contain the name of the appropriate device support module.
The values retrieved from the input link are placed in an array referenced by VAL.
(If the INP link is a constant,
elements can be placed in the array via dbPuts.) NELM specifies the number of elements that the array will hold,
while FTVL specifies the data type of the elements (follow the link in the table above for a list of the available choices).</p>

<p>The RARM field used to cause some device types to re-arm when it was set to 1,
but we don&#39;t know of any such devices any more.</p>

<h3><a class='u'
name="Operator-Display-Parameters"
>Operator Display Parameters</a></h3>

<p>These parameters are used to present meaningful data to the operator.
They display the value and other parameters of the waveform either textually or graphically.</p>

<h4><a class='u'
name="Fields-related-to-Operator-Display"
>Fields related to <i>Operator Display</i></a></h4>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">EGU</td><td class="cell">Engineering Units</td><td class="cell">STRING [16]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">HOPR</td><td class="cell">High Operating Range</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">LOPR</td><td class="cell">Low Operating Range</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">PREC</td><td class="cell">Display Precision</td><td class="cell">SHORT</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">NAME</td><td class="cell">Record Name</td><td class="cell">STRING [61]</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">DESC</td><td class="cell">Descriptor</td><td class="cell">STRING [41]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<p>EGU is a string of up to 16 characters describing the units that the waveform measures.
It is retrieved by the <code>get_units</code> record support routine.</p>

<p>The HOPR and LOPR fields set the upper and lower display limits for array elements referenced by the VAL field.
Both the <code>get_graphic_double</code> and <code>get_control_double</code> record support routines retrieve these fields.</p>

<p>The PREC field determines the floating point precision with which to display the array values.
It is used whenever the <code>get_precision</code> record support routine is called.</p>

<p>See <a href="dbCommonRecord.html#Operator-Display-Parameters" class="podlinkpod"
>Fields Common to All Record Types</a> for more on the record name (NAME) and description (DESC) fields.</p>

<h3><a class='u'
name="Alarm-Parameters"
>Alarm Parameters</a></h3>

<p>The waveform record has the alarm parameters common to all record types.
<a href="dbCommonRecord.html#Alarm-Fields" class="podlinkpod"
>Alarm Fields</a> lists the fields related to alarms that are common to all record types.</p>

<h3><a class='u'
name="Monitor-Parameters"
>Monitor Parameters</a></h3>

<p>These parameters are used to determine when to send monitors placed on the VAL field.
The APST and MPST fields are a menu with choices <code>Always</code> and <code>On Change</code>.
The default is <code>Always</code>,
thus monitors will normally be sent every time the record processes.
Selecting <code>On Change</code> causes a 32-bit hash of the VAL field buffer to be calculated and compared with the previous hash value every time the record processes; the monitor will only be sent if the hash is different,
indicating that the buffer has changed.
Note that there is a small chance that two different value buffers might result in the same hash value,
so for critical systems <code>Always</code> may be a better choice,
even though it re-sends duplicate data.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">APST</td><td class="cell">Post Archive Monitors</td><td class="cell">MENU (<a href='#Menu-waveformPOST'>waveformPOST</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">MPST</td><td class="cell">Post Value Monitors</td><td class="cell">MENU (<a href='#Menu-waveformPOST'>waveformPOST</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">HASH</td><td class="cell">Hash of OnChange data.</td><td class="cell">ULONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h4><a class='u'
name="Menu-waveformPOST"
>Menu waveformPOST</a></h4>

<p>This menu defines the possible choices for <code>APST</code> and <code>MPST</code> fields:</p>
<blockquote><table border="1"><tr>
<th>Index</th><th>Identifier</th><th>Choice String</th></tr>
<tr>
<td class='cell DBD_Menu index'>0</td>
<td class='cell DBD_Menu identifier'>waveformPOST_Always</td>
<td class='cell DBD_Menu choice'>Always</td>
</tr>
<tr>
<td class='cell DBD_Menu index'>1</td>
<td class='cell DBD_Menu identifier'>waveformPOST_OnChange</td>
<td class='cell DBD_Menu choice'>On Change</td>
</tr>
</table></blockquote>


<h3><a class='u'
name="Run-time-Parameters"
>Run-time Parameters</a></h3>

<p>These parameters are used by the run-time code for processing the waveform.
They are not configured using a configuration tool.
Only the VAL field is modifiable at run-time.</p>

<p>VAL references the array where the waveform stores its data.
The BPTR field holds the address of the array.</p>

<p>The NORD field holds a counter of the number of elements that have been read into the array.
It is reset to 0 when the device is rearmed.
The BUSY field indicates if the device is armed but has not yet been digitized.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">VAL</td><td class="cell">Value</td><td class="cell">Set by FTVL</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">BPTR</td><td class="cell">Buffer Pointer</td><td class="cell">NOACCESS</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">No</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NORD</td><td class="cell">Number elements read</td><td class="cell">ULONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">BUSY</td><td class="cell">Busy Indicator</td><td class="cell">SHORT</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Simulation-Mode-Parameters"
>Simulation Mode Parameters</a></h3>

<p>The following fields are used to operate the record in simulation mode.</p>

<p>If SIMM (fetched through SIML) is YES,
the record is put in SIMS severity and the value is fetched through SIOL.
SSCN sets a different SCAN mechanism to use in simulation mode.
SDLY sets a delay (in sec) that is used for asynchronous simulation processing.</p>

<p>See <a href="dbCommonInput.html#Input-Simulation-Fields" class="podlinkpod"
>Input Simulation Fields</a> for more information on simulation mode and its fields.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">SIML</td><td class="cell">Simulation Mode Link</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIMM</td><td class="cell">Simulation Mode</td><td class="cell">MENU (<a href='menuYesNo.html'>menuYesNo</a>)</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIOL</td><td class="cell">Simulation Input Link</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SIMS</td><td class="cell">Simulation Mode Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SDLY</td><td class="cell">Sim. Mode Async Delay</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">-1.0</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">SSCN</td><td class="cell">Sim. Mode Scan</td><td class="cell">MENU (<a href='menuScan.html'>menuScan</a>)</td><td class="cell">Yes</td><td class="cell">65535</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>

<br>
<hr>
<br>


<h2><a class='u'
name="Record-Support"
>Record Support</a></h2>

<h3><a class='u'
name="Record-Support-Routines"
>Record Support Routines</a></h3>

<h4><a class='u'
name="init_record"
>init_record</a></h4>

<pre>   static long init_record(waveformRecord *prec, int pass)</pre>

<p>Using NELM and FTVL space for the array is allocated. The array address is stored in the record.</p>

<p>This routine initializes SIMM with the value of SIML if SIML type is CONSTANT link or creates a channel access link if SIML type is PV_LINK. VAL is likewise initialized if SIOL is CONSTANT or PV_LINK.</p>

<p>This routine next checks to see that device support is available and a device support read routine is defined. If either does not exist, an error message is issued and processing is terminated</p>

<p>If device support includes <code>init_record()</code>, it is called.</p>

<h4><a class='u'
name="process"
>process</a></h4>

<pre>  static long process(waveformRecord *prec)</pre>

<p>See <a href="#Record-Processing" class="podlinkpod"
>&#34;Record Processing&#34;</a> section below.</p>

<h4><a class='u'
name="cvt_dbaddr"
>cvt_dbaddr</a></h4>

<pre>  static long cvt_dbaddr(DBADDR *paddr)</pre>

<p>This is called by dbNameToAddr. It makes the dbAddr structure refer to the actual buffer holding the result.</p>

<h4><a class='u'
name="get_array_info"
>get_array_info</a></h4>

<pre>  static long get_array_info(DBADDR *paddr, long *no_elements, long *offset)</pre>

<p>Obtains values from the array referenced by VAL.</p>

<h4><a class='u'
name="put_array_info"
>put_array_info</a></h4>

<pre>  static long put_array_info(DBADDR *paddr, long nNew)</pre>

<p>Writes values into the array referenced by VAL.</p>

<h4><a class='u'
name="get_units"
>get_units</a></h4>

<pre>  static long get_units(DBADDR *paddr, char *units)</pre>

<p>Retrieves EGU.</p>

<h4><a class='u'
name="get_prec"
>get_prec</a></h4>

<pre>  static long get_precision(DBADDR *paddr, long *precision)</pre>

<p>Retrieves PREC if field is VAL field. Otherwise, calls <code>recGblGetPrec()</code>.</p>

<h4><a class='u'
name="get_graphic_double"
>get_graphic_double</a></h4>

<pre>  static long get_graphic_double(DBADDR *paddr, struct dbr_grDouble *pgd)</pre>

<p>Sets the upper display and lower display limits for a field. If the field is VAL the limits are set to HOPR and LOPR, else if the field has upper and lower limits defined they will be used, else the upper and lower maximum values for the field type will be used.</p>

<p>Sets the following values:</p>

<pre>  upper_disp_limit = HOPR
  lower_disp_limit = LOPR</pre>

<h4><a class='u'
name="get_control_double"
>get_control_double</a></h4>

<pre>  static long get_control_double(DBADDR *paddr, struct dbr_ctrlDouble *pcd)</pre>

<p>Sets the upper control and the lower control limits for a field. If the field is VAL the limits are set to HOPR and LOPR, else if the field has upper and lower limits defined they will be used, else the upper and lower maximum values for the field type will be used.</p>

<p>Sets the following values</p>

<pre>  upper_ctrl_limit = HOPR
  lower_ctrl_limit = LOPR</pre>

<h3><a class='u'
name="Record-Processing"
>Record Processing</a></h3>

<p>Routine process implements the following algorithm:</p>

<ol>
<li>Check to see that the appropriate device support module exists. If it doesn&#39;t, an error message is issued and processing is terminated with the PACT field still set to TRUE. This ensures that processes will no longer be called for this record. Thus error storms will not occur.</li>

<li>Call device support read routine.</li>

<li>If PACT has been changed to TRUE, the device support read routine has started but has not completed writing the new value. In this case, the processing routine merely returns, leaving PACT TRUE.</li>

<li>Check to see if monitors should be invoked.
<ul>
<li>Alarm monitors are invoked if the alarm status or severity has changed.</li>

<li>Archive and value change monitors are invoked if APST or MPST are Always or if the result of the hash calculation is different.</li>

<li>NSEV and NSTA are reset to 0.</li>
</ul>
</li>

<li>Scan forward link if necessary, set PACT FALSE, and return.</li>
</ol>
<br>
<hr>
<br>


<h2><a class='u'
name="Device-Support"
>Device Support</a></h2>

<h3><a class='u'
name="Fields-Of-Interest-To-Device-Support"
>Fields Of Interest To Device Support</a></h3>

<p>Each waveform record must have an associated set of device support routines. The primary responsibility of the device support routines is to obtain a new array value whenever read_wf is called. The device support routines are primarily interested in the following fields:</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">PACT</td><td class="cell">Record active</td><td class="cell">UCHAR</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">DPVT</td><td class="cell">Device Private</td><td class="cell">NOACCESS</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">No</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NSEV</td><td class="cell">New Alarm Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NSTA</td><td class="cell">New Alarm Status</td><td class="cell">MENU (<a href='menuAlarmStat.html'>menuAlarmStat</a>)</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">INP</td><td class="cell">Input Specification</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">NELM</td><td class="cell">Number of Elements</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">FTVL</td><td class="cell">Field Type of Value</td><td class="cell">MENU (<a href='menuFtype.html'>menuFtype</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">RARM</td><td class="cell">Rearm the waveform</td><td class="cell">SHORT</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">BPTR</td><td class="cell">Buffer Pointer</td><td class="cell">NOACCESS</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">No</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NORD</td><td class="cell">Number elements read</td><td class="cell">ULONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">BUSY</td><td class="cell">Busy Indicator</td><td class="cell">SHORT</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Device-Support-Routines"
>Device Support Routines</a></h3>

<p>Device support consists of the following routines:</p>

<h4><a class='u'
name="report"
>report</a></h4>

<pre>  long report(int level)</pre>

<p>This optional routine is called by the IOC command <code>dbior</code> and is passed the report level that was requested by the user. It should print a report on the state of the device support to stdout. The <code>level</code> parameter may be used to output increasingly more detailed information at higher levels, or to select different types of information with different levels. Level zero should print no more than a small summary.</p>

<h4><a class='u'
name="init"
>init</a></h4>

<pre>  long init(int after)</pre>

<p>This optional routine is called twice at IOC initialization time. The first call happens before any of the <code>init_record()</code> calls are made, with the integer parameter <code>after</code> set to 0. The second call happens after all of the <code>init_record()</code> calls have been made, with <code>after</code> set to 1.</p>

<h4><a class='u'
name="init_record"
>init_record</a></h4>

<pre>  long init_record(dbCommon *precord)</pre>

<p>This routine is optional. If provided, it is called by the record support <code>init_record()</code> routine.</p>

<h4><a class='u'
name="get_ioint_info"
>get_ioint_info</a></h4>

<pre>  long get_ioint_info(int cmd, dbCommon *precord, IOSCANPVT *ppvt)</pre>

<p>This routine is called by the ioEventScan system each time the record is added or deleted from an I/O event scan list. <code>cmd</code> has the value (0,1) if the record is being (added to, deleted from) an I/O event list. It must be provided for any device type that can use the ioEvent scanner.</p>

<h4><a class='u'
name="read_wf"
>read_wf</a></h4>

<pre>  long read_wf(waveformRecord *prec)</pre>

<p>This routine must provide a new input value. It returns the following values:</p>

<ul>
<li>0: Success.</li>

<li>Other: Error.</li>
</ul>

<h3><a class='u'
name="Device-Support-For-Soft-Records"
>Device Support For Soft Records</a></h3>

<p>The <code>Soft Channel</code> device support module is provided to read values from other records and store them in arrays. If INP is a constant link, then read_wf does nothing. In this case, the record can be used to hold arrays written via dbPuts. If INP is a database or channel access link, the new array value is read from the link. NORD is set to the number of items in the array.</p>

<p>This module places a value directly in VAL.</p>

<p>If the INP link type is constant, then NORD is set to zero.</p>
</div>


<!-- end doc -->

</body></html>
